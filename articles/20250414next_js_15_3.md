---
title: "Next.jsのバージョン15.3が出たんじゃ"
emoji: "🐈"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react","Next.js","TypeScript",]
published: false
# published_at: 2025-04-07 09:30
---

# 初めに
さてNext.js使いの皆さん、Next.jsがバージョンアップしましたね〜
主に5つの機能がアップデートしました。
- [ビルド用 Turbopack (アルファ版)](https://nextjs.org/blog/next-15-3#turbopack-builds-alpha) : 8000 回以上のテストに合格した、より高速な本番ビルド (99%)
- [Rspack のコミュニティサポート（実験的）](https://nextjs.org/blog/next-15-3#community-support-for-rspack-experimental) : Webpack と互換性のある代替バンドラー
- [クライアントインストルメンテーションフック](https://nextjs.org/blog/next-15-3#client-instrumentation-hook): 早期監視と分析のセットアップ
- [ナビゲーションフック](https://nextjs.org/blog/next-15-3#navigation-hooks): とを使用してルーティングを制御onNavigateするuseLinkStatus
- [TypeScriptプラグインの改善](https://nextjs.org/blog/next-15-3#typescript-plugin-performance-improvements)：大規模コードベースのサポートの改善

正直ごめんなさい、興味あるのがナビゲーションフックだけなんです…ってか上から３つぐらいは肌感じゃわからないので、他の方に託します！（そんなやついないwww）

# ナビゲーションフックについて
さて本当にナビゲーションフックについてしか書きませんので、他の項目に興味がある方はここまでで止めた方がいいです！
- onNavigate
- useLinkStatus

今回のアプデートでは上記2つが新たに追加されました。そしてどちらもかなり使いそうなフックなので一緒に学んでいきましょう！
# onNavigate
このイベントハンドラーは`Linkコンポーネント`の新しいプロパティであり、クライアント側のナビゲーション中に実行され、アプリケーションのルーティング動作を正確に制御できます。
onClickすべてのクリックに対して発生するイベントとは異なり、`onNavigate`はシングルページアプリ（SPA）で使用できます。ナビゲーションにより、コードを実行したり、`preventDefault()`でナビゲーションをキャンセルしたりすることもできます。
この API を使用すると、実際のページ遷移時にのみ実行される遷移アニメーション、ナビゲーション ガード、または分析トラッキングを実装できます。
下記のコードは公式から抜粋しました。
```
import Link from 'next/link'
 
export default function Page() {
  return (
    <Link
      href="/dashboard"
      onNavigate={(e) => {
        // Only executes during SPA navigation
        console.log('Navigating...')
 
        // Optionally prevent navigation
        // e.preventDefault()
      }}
    >
      Dashboard
    </Link>
  )
}
```
例えば、権限を判定して、権限次第でこのページには遷移できないようにさせるとか、dashboardに遷移する際にログインしているユーザーかどうか判定して、ログインしているユーザーなら遷移させる。ログインしていなかったら、ダッシュボードに遷移させないみたいなことができそうですね！
```
'use client';

import Link from 'next/link'
import { use } from 'react';
import { useUser } from '@/lib/auth';

export default function ActivityPage() {
  const { userPromise } = useUser();
  const user = use(userPromise);

  return (
    <section className="flex-1 p-4 lg:p-8">
      <h1 className="text-lg lg:text-2xl font-medium mb-6">Activity</h1>
      <Link 
        href="/dashboard"
        onNavigate={(e) => {
          console.log('Navigating to dashboard');
          if (!user) {
            alert('ログインしていないため、遷移できません');
            e.preventDefault();
            redirect('/login');
          }
          return true;
        }}
      >Go to Dashboard
      </Link>
    </section>
  );
}
```
こちらは「ログインしているユーザーでなければダッシュボードに遷移させずに、ログイン画面に遷移」という処理の実装例です。
```
  if (!user) {
    redirect('/login');
  }
```
正直、上記のような早期リターンで返した方が早いのではとも思っていますが、下記の処理だとそもそも画面が開けないので、どんな画面かもわからないですね。
```
  { user && (
    ~~~~~（省略）
  )}
```
これでも対応できそうですが、遷移できるボタン（実際のコードと異なりますが、ボタンの方がイメージつくと思うので、ボタンとします）が消えてしまいます。例えば、権限によって表示されるボタンがあるとかの場合、ユーザー的にはわからないですよね…
権限によらずボタンが表示されて「権限ないぞ」ってメッセージが出た方がわかりやすいですよね〜
# useLinkStatus