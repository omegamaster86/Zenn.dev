---
title: "ITエンジニア用語を知りたいんじゃ"
emoji: "📖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["IT用語","初学者"]
published: false
# published_at: 
---

# 初めに
いや〜暑くなったり、寒くなったりよくわからない季節ですね〜
体調管理にはくれぐれも気をつけてください〜
さて今回この記事で解説する用語は[聞き流しOK！IT/エンジニア用語31選！徹底解説【プログラミング編】](https://www.youtube.com/watch?v=5kpG4u8VmiA)で菊本様が発表した用語です。
是非上記の動画をご覧になった上で、「あれ…いまいちピンとこない」という方はご参考までにご覧になってください！


## アルゴリズム
問題を解決するための手順や計算方法

## データ構造
### 定義
データ構造（Data Structure）とは、コンピュータ上でデータを効率的に格納・管理・操作するための枠組み（仕組み）です。メモリ上にどのようにデータを並べるか、どのようにアクセスするかといった方法を定義し、目的に応じて最適な方法を選択します。
なぜ重要か
- パフォーマンスの向上
同じデータを保持する場合でも、データ構造の設計次第で探索・挿入・削除などの操作にかかる時間（アルゴリズムの時間計算量）が大きく変わる。
- メモリ使用量の最適化
データ構造によっては余分な領域を確保したり、逆に必要なときに柔軟に領域を拡張できたりするものがある。
- コードの可読性・保守性
目的に即したデータ構造を使うことで、コードがシンプルになり、バグを減らせる。
| データ構造 | 概要 | 探索（平均的） | 挿入／削除（平均的）| 主な用途 |
| -------------------- | ----------------------------------------- | ---------------- | ------------------- | ---------------------- |
| 配列（Array）            | 要素がメモリ上で連続して並ぶ静的なコンテナ                     | O(1)  ※インデックス指定  | O(n) （中央付近だとシフトが必要） | ランダムアクセス、固定長データ保存      |
| 連結リスト（Linked List）   | 各要素が「値」と「次の要素へのポインタ」を持つ動的リスト              | O(n)             | O(1)※ノードを既知の場合      | 挿入・削除が多いリスト管理          |
| スタック（Stack）          | LIFO（後入れ先出し）で要素を扱う。配列または連結リストで実装          | O(1)  ※トップ       | O(1)                | 関数呼び出し管理、Undo機能        |
| キュー（Queue）           | FIFO（先入れ先出し）で要素を扱う。配列または連結リストで実装          | O(1)  ※先頭アクセス    | O(1)                | タスク管理、バッファリング          |
| ヒープ（Heap）            | 完全二分木を配列で管理し、最大値または最小値を高速に取り出せる優先度付きキュー   | O(1)  ※最大／最小値取得  | O(log n)            | プライオリティキュー、ソート（ヒープソート） |
| 二分探索木（BST）           | 左部分木は親より小さい値、右部分木は親より大きい値を持つ動的ツリー構造       | O(log n) ※平衡木の場合 | O(log n) ※平衡木の場合    | 辞書順データの動的管理、中間順遍歴      |
| 平衡二分探索木（AVL木、赤黒木など）  | 自己再構成によって高さを O(log n) に保つ二分探索木            | O(log n)         | O(log n)            | 高速な挿入・削除・探索が必須の場面      |
| ハッシュテーブル（Hash Table） | キーをハッシュ関数でインデックスに変換し、キー→値の対応を定数時間的に行うコンテナ | O(1) ※平均         | O(1) ※平均            | 高速なキー検索、辞書的データ管理       |
| グラフ（Graph）           | 頂点（ノード）と辺（エッジ）から成る構造。隣接リストや隣接行列で実装        | –                | –                   | ネットワーク、マップ、依存関係管理      |
| トライ（Trie）            | 文字列の集合を木構造で管理。接頭辞検索を効率化する                 | O(k) （k=文字数）     | O(k)                | 辞書、オートコンプリート、文字列検索     |
### 配列（Array）
構造
- メモリ上に要素が連続して並ぶ領域を確保し、インデックス（0 から始まる整数）で直接アクセスする。
- サイズは固定長（言語によっては可変長配列もあるが、実装上は内部で再確保する）。
主な操作と計算量
- arr[i]（ランダムアクセス） → O(1)
- append（末尾への追加） → 言語によっては amortized O(1)
- insert（先頭や中央へ挿入） → O(n) （以降の要素を後ろへシフトする必要がある）
- delete（先頭や中央からの削除） → O(n)
特徴・用途
- メモリ局所性が高く、高速なランダムアクセスが可能。
- サイズ変更や真ん中での挿入・削除が非効率。
- 配列をベースにしたスタックやキュー（環状バッファ）構造も一般的。

## オブジェクト指向

## 手続き型プログラミング

## 関数型プログラミング

## コンパイル

## ノード

## 非同期処理

## 例外処理

## コールバック

## クリーンアップ関数

## イベント駆動

## API

## A2A

## MCP

## プロトコル

## イミュータブル

## ミュータブル

## スコープ

## プリミティブ

## クロージャ

## オーバーロード

## オーバーライド

## スタック領域

## ヒープ領域

## ガベージコレクション

## シリアライズ

## ケルベロス認証

