---
title: "cursor-ssd-packageをOSSとしてリリースしたんじゃ"
emoji: "🎆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["cursor","AI","AI駆動開発"]
published: false
# published_at: 2025-12-13 20:30
publication_name: "genai"
---

# 初めに
いや〜今年も終わりましたね〜
みなさん今年はどんな年になりましたか？
私はCursorが好きなので、Cursorの情報ばかり追いかけた1年になりました…これからもどんどん進化していくと楽しみでもあり、恐ろしいですね〜
さて話は変わりますがkiroというエディタをご存知ですか？仕様書駆動開発の先駆者とも言えるエディタです。kiroがベータ版でリリースされた時には、「Claudeでkiroの仕様書駆動開発を実現」というような記事も散見されました。その時はなにも思わなかったのですが、Cursorの進化がすごくうまく使いこなせれば、数ページのアプリならすぐに完成してしまいます。ですが自分で確認する（レビュー）時にかなり大変な思いをしました。もう少し分けてくれれば良いのに、kiroみたいにTODOを一覧に出してくれれば対応箇所も差分わかりやすいのにと思っていました。そんな時にcc-sddと出会いました。
https://github.com/gotalab/cc-sdd/tree/main
これは良いぞ！
でももう少し欲しいものがある。要件を決めた時に、テーブル定義やER図、とかも欲しいな〜コードを作成したらテスト作成して欲しいな〜
そうだ、好きなようにアップデートしたら良いんだと思いつきました。現状はまだ単体テストを書かせるルールは組み込んでいませんがそれはv2に取っておきます（言いたいだけ）ということで、CursorがVScodeをフォークしたように、私もcc-sddをフォークして、cursor-ssd-packageを作成しました〜👏👏
本日はその中身と、追加したコマンドやテーブル定義のレベル感をお伝えできればと思いますので、お付き合いください！

# cursor-ssd-package
https://github.com/omegamaster86/cursor-sdd-package
いよ！初のOSS活動であるcursor-ssd-packageです！（名前が微妙なので、良いネーミングセンスある方、改名案募集しています）
まずは`npx cursor-sdd@latest`でインストールしてください。
現在のところ下記のコマンドを使用できます
| コマンド | 説明 |
|---------|------|
| `/init` | プロジェクト仕様の初期化 |
| `/requirements` | 要件定義書の生成 |
| `/requirements-import` | 既存要件のインポート |
| `/design` | 技術設計書の作成 |
| `/check-design` | 設計書の検証 |
| `/tasks` | タスクの生成 |
| `/impl` | 実装の開始 |
| `/status` | 進捗確認 |
| `/difference-check` | 差分チェック |

もう少し詳細に見ていくと
### /init - プロジェクト仕様の初期化
いつ: プロジェクト開始時、最初に1回だけ実行
結果: .sdd/specs/init.json が生成され、プロジェクトの基本情報（名前、説明、技術スタック等）が定義される。以降のすべてのコマンドはこの設定を参照する。
### /requirements - 要件定義書の生成
いつ: /init 完了後、機能の実装前
結果: .sdd/specs/requirements.md が生成される。ユーザーストーリー、機能要件、非機能要件がEARS形式で構造化され、曖昧さのない要件定義が完成する。
### /requirements-import - 既存要件のインポート
いつ: 既に要件定義書やPRDが存在する場合
結果: 既存ドキュメントをSDD形式の requirements.md に変換。外部ツールで作成した要件をそのまま活用できる。
### /design - 技術設計書の作成
いつ: 要件定義完了後、実装開始前
結果: .sdd/specs/design.md が生成される。アーキテクチャ、コンポーネント構成、API設計、データモデルなど技術的な設計が文書化される。
### /check-design - 設計書の検証
いつ: /design 完了後、実装開始前
結果: 設計書の整合性・完全性をチェック。要件との紐付け漏れ、矛盾点、未定義の依存関係などが検出・報告される。
### /tasks - タスクの生成
いつ: 設計書の検証完了後
結果: .sdd/specs/tasks.md が生成される。設計書から実装タスクが自動分解され、依存関係と優先度が整理される。そのまま実装に着手できる粒度になる。
### /impl - 実装の開始
いつ: タスク生成後、各タスクの実装時
結果: 選択したタスクに基づいてコード実装が開始される。設計書・タスク定義を参照しながら、仕様に沿った実装が行われる。
### /status - 進捗確認
いつ: 実装中いつでも
結果: 現在のタスク進捗状況が表示される。完了タスク、進行中タスク、残タスクが一覧化され、プロジェクト全体の進捗が把握できる。
### /difference-check - 差分チェック
いつ: 実装完了後、または定期的なレビュー時
結果: 設計書と実際の実装コードの差分を検出。仕様からの乖離や実装漏れが報告され、ドキュメントと実装の同期が保たれる。

各コマンドの実行の順番はこんな感じです
```:
/init → /requirements → /design → /tasks → /impl
                ↑                    ↓
            /status ←←←←←←←←←←←←←←←
```
:::message
ここで覚えなくても、コマンド実行後にチャットで次に実行するコマンドを教えてくれるので、大丈夫です！
:::

早速どんなふうに動作するのか見ていきましょう〜