---
title: "CursorのV2.2やビジュアルエディタがリリースされたんじゃ（気になるアドベントカレンダーを添えて）"
emoji: "🌕"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["cursor","AI","AI駆動開発"]
published: false
# published_at: 2025-12-13 21:30
publication_name: "genai"
---

# 初めに
もうすぐ今年も終わりですね〜企業によっては26日からお休みの会社もあり、羨ましい限りです…
年末は格付けチャックと相棒が我が家の定番ですが、皆さんの家では定番はありますか？
さて、今回もCursorのV2.2とV2.1のアップデート情報を早速内容を見ていきましょう！

## 先に結論（TL;DR）
- **v2.2**: いちばんデカいのは **Debug Mode**（実行ログ前提で原因を詰める）と、**Browserのビジュアルエディタ**（UIを触って→Agentでコード反映）。あと地味に効くのが **Plan Modeの強化（Mermaid / To-do分割）**、**Multi-agent judging**、**Pinned chats**。
- **v2.1**: **Plan Modeの作り込み**が進み、さらに **AI Code Reviews（Cursor内でのレビュー）** と **Instant Grep（Agentのgrepが即時）** が入って開発テンポが上がる。

:::message
この情報は2025/12/13時点での情報です。
最新情報は公式をしっかり確認するようにしてください。
:::

## Cursor 2.2（2025年12月10日リリース）

### 1 Debug Mode
AIエージェントによる新しいデバッグ実行モードが追加されました。エージェントがコードベース全体を読み込み、原因になりそうな点について複数の仮説を立てます。その後コードにランタイムログ出力を埋め込み、複数の不具合原因仮説を立て、人間（開発者）と対話しながらバグを再現・修正します。（多くの場合、必要なのは2〜3行程度のピンポイントな変更だけで、通常のエージェントとのやりとりで返されがちな、何百行もの当てずっぽうなコードとはまったく異なります。）スタックや言語を問わず動作し、これまでAI単独では困難だった厄介なバグも再現とログ分析を通じて確実に修正できるよう支援します。
https://cursor.com/ja/blog/debug-mode

### 設定方法
![](/images/cursor-update-v2_2/1.png)
Debugをしてするだけなので、特段何も必要はないです！

### 主な機能

1. **仮説ベースのデバッグ**
   - バグの原因について3〜5個の仮説を立てる（コードを読んだ後で、原因になりそうな点に関する）
   - 各仮説を検証するための計装ログを挿入（これにより、バグが発生したときに実際に何が起きているのかを示す具体的なデータをエージェントが取得できる）

2. **自動ロギングシステム**
   - HTTPエンドポイント経由でログを収集
   - NDJSON形式でログファイルに保存（`.cursor/debug.log`）
   - JS/TSでは`fetch`でログ送信、他言語は直接ファイル書き込み

3. **エビデンスベースの修正**
   - 「コードを見ただけの推測」ではなく、実際のランタイムデータで原因特定
   - ログで仮説を CONFIRMED / REJECTED / INCONCLUSIVE に分類

4. **修正後の検証フロー**
   - 修正後もログを残したまま再実行
   - before/after のログ比較で修正効果を確認
   - ユーザー確認後にのみ計装を削除

### Cursorデバッグモードの詳細な使い方

### 1. ワークフロー全体像

```
バグ報告 → 仮説生成(3-5個) → ログ計装 → 再現実行 → ログ分析 → 修正 → 検証 → ログ削除
```

### 2. ログ計装の実装方法

#### JavaScript/TypeScript の場合
```javascript
// #region agent log
fetch('http://127.0.0.1:7242/ingest/SESSION_ID',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'UserList.tsx:42',message:'ユーザー取得前',data:{userId,filters},timestamp:Date.now(),sessionId:'debug-session',hypothesisId:'A'})}).catch(()=>{});
// #endregion
```

#### Python の場合
```python
# region agent log
import json; open('/path/to/debug.log','a').write(json.dumps({'location':'main.py:15','message':'API呼び出し前','data':{'params':params},'timestamp':time.time(),'hypothesisId':'B'})+'\n')
# endregion
```

### 3. ログを入れる場所（3〜8箇所）

| 場所 | 目的 |
|------|------|
| 関数の入口 | パラメータの値を確認 |
| 関数の出口 | 戻り値を確認 |
| 重要な処理の前後 | 値の変化を追跡 |
| if/else分岐内 | どのパスが実行されたか |
| 状態更新時 | state/変数の変化 |
| エラーハンドラ内 | 例外の詳細 |

### 4. 仮説の立て方（例）

バグ：「ボタンをクリックしても何も起きない」

| 仮説ID | 内容 |
|--------|------|
| A | onClick ハンドラが呼ばれていない |
| B | API リクエストが失敗している |
| C | レスポンスのパースでエラー |
| D | state 更新後に再レンダリングされていない |
| E | 条件分岐で早期 return している |

### 5. ログ分析の例

```json
{"location":"Button.tsx:15","message":"onClick開始","hypothesisId":"A","timestamp":1733456789000}
{"location":"api.ts:42","message":"fetch前","data":{"url":"/api/users"},"hypothesisId":"B"}
{"location":"api.ts:48","message":"fetch後","data":{"status":500,"body":"Internal Error"},"hypothesisId":"B"}
```

**分析結果：**
- 仮説A: CONFIRMED（onClickは呼ばれている）
- 仮説B: CONFIRMED（APIが500エラー）→ **根本原因**
- 仮説C〜E: REJECTED（APIエラーで到達していない）

### 6. 修正→検証のフロー

1. **修正を実装**（ログは消さない！）
2. **runId を変更**して再実行を依頼
   ```javascript
   runId: 'post-fix'  // 修正前は 'run1' だった
   ```
3. **before/after 比較**
   - before: `{"status":500}`
   - after: `{"status":200,"data":[...]}`
4. **ユーザー確認後**にログ削除

### 7. よくある注意点

| ❌ やってはいけない | ✅ 正しい方法 |
|-------------------|--------------|
| コードだけ見て推測で修正 | ログ証拠を取ってから修正 |
| setTimeout で「直った」 | 適切なイベント/ライフサイクル使用 |
| 検証前にログ削除 | ユーザー確認後に削除 |
| 全仮説棄却で諦める | 別の観点で新仮説を立てる |

### 8. 実際の依頼の仕方

```
「〇〇をクリックしても△△が表示されない」
「APIを叩くと undefined が返ってくる」
「特定の条件でだけクラッシュする」
```
こう伝えてもらえれば、仮説を立ててログを入れていくので、ぜひ試してみてください！


### 2 Browser ビジュアルエディタ
エディタ内蔵のブラウザ機能が強化され、**ブラウザレイアウト＆スタイルエディタ（ビジュアルエディタ）**が登場しました。エディタに組み込まれたブラウザサイドバーとコンポーネントツリー上で、要素をドラッグ＆ドロップして配置を変えたり、色やCSSスタイルをリアルタイムに編集できます。編集内容は即座にコードに反映可能で、複数の要素を選択して「この部分を大きく」などテキストで指示すれば、エージェントが対応するコード変更を自動実行してくれます。デザインとコードの垣根を低くし、画面上の操作が直接コード修正につながる統一開発環境を実現しています。
https://cursor.com/ja/blog/browser-visual-editor



### 3 Plan Mode 改善：MermaidとTo-do分割が地味に効く
v2.2で Plan Mode は
- **Mermaid図をインライン表示**（設計の共有がラク）
- **To-do単位で別Agentに投げられる**

この2つが熱い。

「計画を出す→全部まとめて実装」だと、結局レビューが重いし並列化もしにくい。
**To-doを切って、複数Agentで走らせて、judgingで勝ち案を選ぶ**のが v2.2 の勝ち筋。

### 4 Multi-agent judging：並列の“採用判断”まで自動化
複数Agentを並列で走らせたあと、Cursorが **どれが良さそうか推薦**してくれる。

- 「同じ指示を3モデルに投げて、いちばん筋が良い差分を採用」
- 「安全寄り / 速度寄り / 変更最小」みたいに方針違いの案を並べる

がやりやすくなる。

### 5 Pinned chats：作業文脈が消えない
地味だけど効く。プロジェクトの前提（アーキ方針、禁止事項、デバッグ手順）を**チャットとして固定**できるのは、地味に生産性が伸びる。


## v2.1 のポイント（v2.2の前段として重要）

### 1 Plan Mode（改善版）：質問→計画の質を上げる
v2.1で Plan Mode は
- **計画前に確認質問を挟む**
- **計画内を検索（⌘+F）できる**

が入って、雑な計画で突っ走る事故が減る。

### 2 AI Code Reviews：Cursor内で“変更点レビュー→修正”が回る
いままで「PRに上げてBugbot/人が見る」が中心だったのが、Cursor内でのAIレビューが入り、
**ローカルで直してから出す**がより自然になる。

※ Bugbot（GitHub/GitLab等に出るレビュー）も引き続き併用前提。

### 3 Instant Grep（Beta）：Agentのgrepが即時
Agentがコードベース探索で叩くgrepが速くなって、**探索→仮説→修正**のループが短くなる。


## どう使う？（最短の型）
- **バグ調査**: まず **Debug Mode** でログ→原因確定→最小修正→再現確認
- **UI改善**: Browserビジュアルエディタで触って形に→Agent反映→必要なら再度触る
- **大きめ改修**: Plan Mode→To-do分割→複数Agent並列→judging→採用→レビュー


## 余談：v2.1以降の“おすすめ運用”
- **/commands を育てる**: 定型の作業（レビュー観点、PRテンプレ、migration手順）を `.cursor/commands` に落としておくと、以後の開発体験が安定する
- **チャットをピン留めして「仕様」を固定**: 仕様が揺れるほど差分が荒れるので、前提はPinned chatsに集約すると良い
